/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Register a callback function that will receive logging event information.
 * An absent callback will unregister an existing callback function.
 * The log level defaults to INFO, it can be set to one of ERROR, WARN, INFO, DEBUG, or TRACE.
 */
export function loggingCallback(callback?: (level: string, target: string, message: string) => void, level?: string): void
/** The builder for an ngrok session. */
export class NgrokSessionBuilder {
  /** Create a new session builder */
  constructor()
  /**
   * Configures the session to authenticate with the provided authtoken. You
   * can [find your existing authtoken] or [create a new one] in the ngrok
   * dashboard.
   *
   * See the [authtoken parameter in the ngrok docs] for additional details.
   *
   * [find your existing authtoken]: https://dashboard.ngrok.com/get-started/your-authtoken
   * [create a new one]: https://dashboard.ngrok.com/tunnels/authtokens
   * [authtoken parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#authtoken
   */
  authtoken(authtoken: string): this
  /**
   * Shortcut for calling [SessionBuilder::authtoken] with the value of the
   * NGROK_AUTHTOKEN environment variable.
   */
  authtokenFromEnv(): this
  /**
   * Configures how often the session will send heartbeat messages to the ngrok
   * service to check session liveness.
   *
   * See the [heartbeat_interval parameter in the ngrok docs] for additional
   * details.
   *
   * [heartbeat_interval parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#heartbeat_interval
   */
  heartbeatInterval(heartbeatInterval: number): this
  /**
   * Configures the duration to wait for a response to a heartbeat before
   * assuming the session connection is dead and attempting to reconnect.
   *
   * See the [heartbeat_tolerance parameter in the ngrok docs] for additional
   * details.
   *
   * [heartbeat_tolerance parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#heartbeat_tolerance
   */
  heartbeatTolerance(heartbeatTolerance: number): this
  /**
   * Configures the opaque, machine-readable metadata string for this session.
   * Metadata is made available to you in the ngrok dashboard and the Agents API
   * resource. It is a useful way to allow you to uniquely identify sessions. We
   * suggest encoding the value in a structured format like JSON.
   *
   * See the [metdata parameter in the ngrok docs] for additional details.
   *
   * [metdata parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#metadata
   */
  metadata(metadata: string): this
  /**
   * Configures the network address to dial to connect to the ngrok service.
   * Use this option only if you are connecting to a custom agent ingress.
   *
   * See the [server_addr parameter in the ngrok docs] for additional details.
   *
   * [server_addr parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#server_addr
   */
  serverAddr(addr: string): this
  /**
   * Configures the TLS client used to connect to the ngrok service while
   * establishing the session. Use this option only if you are connecting through
   * a man-in-the-middle or deep packet inspection proxy. Pass in the bytes of the certificate
   * to be used to validate the connection, then override the address to connect to via
   * the connector call.
   *
   * Roughly corresponds to the [root_cas parameter in the ngrok docs].
   *
   * [root_cas parameter in the ngrok docs]: https://ngrok.com/docs/ngrok-agent/config#root_cas
   */
  tlsConfig(certBytes: Uint8Array): this
  /**
   * Configures a function which is called to establish the connection to the
   * ngrok service. Use this option if you need to connect through an outbound
   * proxy. In the event of network disruptions, it will be called each time
   * the session reconnects. If the handler responds with a string it will be
   * used as the new address to connect to, e.g. "192.168.1.1:443".
   */
  connector(handler: (addr: string, error?: string) => string): this
  /**
   * Configures a function which is called when the ngrok service requests that
   * this [Session] stops. Your application may choose to interpret this callback
   * as a request to terminate the [Session] or the entire process.
   *
   * Errors returned by this function will be visible to the ngrok dashboard or
   * API as the response to the Stop operation.
   *
   * Do not block inside this callback. It will cause the Dashboard or API
   * stop operation to time out. Do not call [std::process::exit] inside this
   * callback, it will also cause the operation to time out.
   */
  handleStopCommand(handler: () => void): this
  /**
   * Configures a function which is called when the ngrok service requests
   * that this [Session] updates. Your application may choose to interpret
   * this callback as a request to restart the [Session] or the entire
   * process.
   *
   * Errors returned by this function will be visible to the ngrok dashboard or
   * API as the response to the Restart operation.
   *
   * Do not block inside this callback. It will cause the Dashboard or API
   * stop operation to time out. Do not call [std::process::exit] inside this
   * callback, it will also cause the operation to time out.
   */
  handleRestartCommand(handler: () => void): this
  /**
   * Configures a function which is called when the ngrok service requests
   * that this [Session] updates. Your application may choose to interpret
   * this callback as a request to update its configuration, itself, or to
   * invoke some other application-specific behavior.
   *
   * Errors returned by this function will be visible to the ngrok dashboard or
   * API as the response to the Restart operation.
   *
   * Do not block inside this callback. It will cause the Dashboard or API
   * stop operation to time out. Do not call [std::process::exit] inside this
   * callback, it will also cause the operation to time out.
   */
  handleUpdateCommand(handler: (update: UpdateRequest) => void): this
  /**
   * Call the provided handler whenever a heartbeat response is received,
   * with the latency in milliseconds.
   *
   * If the handler returns an error, the heartbeat task will exit, resulting
   * in the session eventually dying as well.
   */
  handleHeartbeat(handler: (latency: number) => void): this
  /** Attempt to establish an ngrok session using the current configuration. */
  connect(): Promise<NgrokSession>
}
/** An ngrok session. */
export class NgrokSession {
  /** Start building a tunnel backing an HTTP endpoint. */
  httpEndpoint(): NgrokHttpTunnelBuilder
  /** Start building a tunnel backing a TCP endpoint. */
  tcpEndpoint(): NgrokTcpTunnelBuilder
  /** Start building a tunnel backing a TLS endpoint. */
  tlsEndpoint(): NgrokTlsTunnelBuilder
  /** Start building a labeled tunnel. */
  labeledTunnel(): NgrokLabeledTunnelBuilder
  /** Close a tunnel with the given ID. */
  closeTunnel(id: string): Promise<void>
}
export class UpdateRequest {
  /** The version that the agent is requested to update to. */
  version: string
  /** Whether or not updating to the same major version is sufficient. */
  permitMajorVersion: boolean
}
/**r" An ngrok tunnel backing an HTTP endpoint. */
export class NgrokHttpTunnel {
  /** The URL that this tunnel backs. */
  url(): string
  /** The protocol of the endpoint that this tunnel backs. */
  proto(): string
  /** Returns a tunnel's unique ID. */
  id(): string
  /**
   * Returns a human-readable string presented in the ngrok dashboard
   * and the Tunnels API. Use the [HttpTunnelBuilder::forwards_to],
   * [TcpTunnelBuilder::forwards_to], etc. to set this value
   * explicitly.
   */
  forwardsTo(): string
  /** Returns the arbitrary metadata string for this tunnel. */
  metadata(): string
  /** Forward incoming tunnel connections to the provided TCP address. */
  forwardTcp(addr: string): Promise<void>
  /**
   * Forward incoming tunnel connections to the provided file socket path.
   * On Linux/Darwin addr can be a unix domain socket path, e.g. "/tmp/ngrok.sock"
   * On Windows addr can be a named pipe, e.e. "\\.\pipe\an_ngrok_pipe"
   */
  forwardPipe(addr: string): Promise<void>
  /**
   * Close the tunnel.
   *
   * This is an RPC call that must be `.await`ed.
   * It is equivalent to calling `Session::close_tunnel` with this
   * tunnel's ID.
   */
  close(): Promise<void>
}
/**r" An ngrok tunnel backing a TCP endpoint. */
export class NgrokTcpTunnel {
  /** The URL that this tunnel backs. */
  url(): string
  /** The protocol of the endpoint that this tunnel backs. */
  proto(): string
  /** Returns a tunnel's unique ID. */
  id(): string
  /**
   * Returns a human-readable string presented in the ngrok dashboard
   * and the Tunnels API. Use the [HttpTunnelBuilder::forwards_to],
   * [TcpTunnelBuilder::forwards_to], etc. to set this value
   * explicitly.
   */
  forwardsTo(): string
  /** Returns the arbitrary metadata string for this tunnel. */
  metadata(): string
  /** Forward incoming tunnel connections to the provided TCP address. */
  forwardTcp(addr: string): Promise<void>
  /**
   * Forward incoming tunnel connections to the provided file socket path.
   * On Linux/Darwin addr can be a unix domain socket path, e.g. "/tmp/ngrok.sock"
   * On Windows addr can be a named pipe, e.e. "\\.\pipe\an_ngrok_pipe"
   */
  forwardPipe(addr: string): Promise<void>
  /**
   * Close the tunnel.
   *
   * This is an RPC call that must be `.await`ed.
   * It is equivalent to calling `Session::close_tunnel` with this
   * tunnel's ID.
   */
  close(): Promise<void>
}
/**r" An ngrok tunnel bcking a TLS endpoint. */
export class NgrokTlsTunnel {
  /** The URL that this tunnel backs. */
  url(): string
  /** The protocol of the endpoint that this tunnel backs. */
  proto(): string
  /** Returns a tunnel's unique ID. */
  id(): string
  /**
   * Returns a human-readable string presented in the ngrok dashboard
   * and the Tunnels API. Use the [HttpTunnelBuilder::forwards_to],
   * [TcpTunnelBuilder::forwards_to], etc. to set this value
   * explicitly.
   */
  forwardsTo(): string
  /** Returns the arbitrary metadata string for this tunnel. */
  metadata(): string
  /** Forward incoming tunnel connections to the provided TCP address. */
  forwardTcp(addr: string): Promise<void>
  /**
   * Forward incoming tunnel connections to the provided file socket path.
   * On Linux/Darwin addr can be a unix domain socket path, e.g. "/tmp/ngrok.sock"
   * On Windows addr can be a named pipe, e.e. "\\.\pipe\an_ngrok_pipe"
   */
  forwardPipe(addr: string): Promise<void>
  /**
   * Close the tunnel.
   *
   * This is an RPC call that must be `.await`ed.
   * It is equivalent to calling `Session::close_tunnel` with this
   * tunnel's ID.
   */
  close(): Promise<void>
}
/**r" A labeled ngrok tunnel. */
export class NgrokLabeledTunnel {
  /** The labels this tunnel was started with. */
  labels(): Record<string, string>
  /** Returns a tunnel's unique ID. */
  id(): string
  /**
   * Returns a human-readable string presented in the ngrok dashboard
   * and the Tunnels API. Use the [HttpTunnelBuilder::forwards_to],
   * [TcpTunnelBuilder::forwards_to], etc. to set this value
   * explicitly.
   */
  forwardsTo(): string
  /** Returns the arbitrary metadata string for this tunnel. */
  metadata(): string
  /** Forward incoming tunnel connections to the provided TCP address. */
  forwardTcp(addr: string): Promise<void>
  /**
   * Forward incoming tunnel connections to the provided file socket path.
   * On Linux/Darwin addr can be a unix domain socket path, e.g. "/tmp/ngrok.sock"
   * On Windows addr can be a named pipe, e.e. "\\.\pipe\an_ngrok_pipe"
   */
  forwardPipe(addr: string): Promise<void>
  /**
   * Close the tunnel.
   *
   * This is an RPC call that must be `.await`ed.
   * It is equivalent to calling `Session::close_tunnel` with this
   * tunnel's ID.
   */
  close(): Promise<void>
}
/**r" An ngrok tunnel backing an HTTP endpoint. */
export class NgrokHttpTunnelBuilder {
  /**
   * The scheme that this edge should use.
   * Defaults to [Scheme::HTTPS].
   */
  scheme(scheme: string): this
  /** The domain to request for this edge. */
  domain(domain: string): this
  /** Certificates to use for client authentication at the ngrok edge. */
  mutualTlsca(mutualTlsca: Uint8Array): this
  /** Enable gzip compression for HTTP responses. */
  compression(): this
  /** Convert incoming websocket connections to TCP-like streams. */
  websocketTcpConversion(): this
  /**
   * Reject requests when 5XX responses exceed this ratio.
   * Disabled when 0.
   */
  circuitBreaker(circuitBreaker: number): this
  /** with_request_header adds a header to all requests to this edge. */
  requestHeader(name: string, value: string): this
  /** with_response_header adds a header to all responses coming from this edge. */
  responseHeader(name: string, value: string): this
  /** with_remove_request_header removes a header from requests to this edge. */
  removeRequestHeader(name: string): this
  /** with_remove_response_header removes a header from responses from this edge. */
  removeResponseHeader(name: string): this
  /**
   * Credentials for basic authentication.
   * If not called, basic authentication is disabled.
   */
  basicAuth(username: string, password: string): this
  /**
   * OAuth configuration.
   * If not called, OAuth is disabled.
   */
  oauth(provider: string, allowEmails?: Array<string> | undefined | null, allowDomains?: Array<string> | undefined | null, scopes?: Array<string> | undefined | null): this
  /**
   * OIDC configuration.
   * If not called, OIDC is disabled.
   */
  oidc(issuerUrl: string, clientId: string, clientSecret: string, allowEmails?: Array<string> | undefined | null, allowDomains?: Array<string> | undefined | null, scopes?: Array<string> | undefined | null): this
  /**
   * WebhookVerification configuration.
   * If not called, WebhookVerification is disabled.
   */
  webhookVerification(provider: string, secret: string): this
  /** Tunnel-specific opaque metadata. Viewable via the API. */
  metadata(metadata: string): this
  /** Begin listening for new connections on this tunnel. */
  listen(bind?: boolean | undefined | null): Promise<NgrokHttpTunnel>
  /**
   * Restriction placed on the origin of incoming connections to the edge to only allow these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  allowCidr(cidr: string): this
  /**
   * Restriction placed on the origin of incoming connections to the edge to deny these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  denyCidr(cidr: string): this
  /** The version of PROXY protocol to use with this tunnel "1", "2", or "" if not using. */
  proxyProto(proxyProto: string): this
  /**
   * Tunnel backend metadata. Viewable via the dashboard and API, but has no
   * bearing on tunnel behavior.
   */
  forwardsTo(forwardsTo: string): this
}
/**r" An ngrok tunnel backing a TCP endpoint. */
export class NgrokTcpTunnelBuilder {
  /** The TCP address to request for this edge. */
  remoteAddr(remoteAddr: string): this
  /** Tunnel-specific opaque metadata. Viewable via the API. */
  metadata(metadata: string): this
  /** Begin listening for new connections on this tunnel. */
  listen(bind?: boolean | undefined | null): Promise<NgrokTcpTunnel>
  /**
   * Restriction placed on the origin of incoming connections to the edge to only allow these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  allowCidr(cidr: string): this
  /**
   * Restriction placed on the origin of incoming connections to the edge to deny these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  denyCidr(cidr: string): this
  /** The version of PROXY protocol to use with this tunnel "1", "2", or "" if not using. */
  proxyProto(proxyProto: string): this
  /**
   * Tunnel backend metadata. Viewable via the dashboard and API, but has no
   * bearing on tunnel behavior.
   */
  forwardsTo(forwardsTo: string): this
}
/**r" An ngrok tunnel backing a TLS endpoint. */
export class NgrokTlsTunnelBuilder {
  /** The domain to request for this edge. */
  domain(domain: string): this
  /** Certificates to use for client authentication at the ngrok edge. */
  mutualTlsca(mutualTlsca: Uint8Array): this
  /** The key to use for TLS termination at the ngrok edge in PEM format. */
  termination(certPem: Uint8Array, keyPem: Uint8Array): this
  /** Tunnel-specific opaque metadata. Viewable via the API. */
  metadata(metadata: string): this
  /** Begin listening for new connections on this tunnel. */
  listen(bind?: boolean | undefined | null): Promise<NgrokTlsTunnel>
  /**
   * Restriction placed on the origin of incoming connections to the edge to only allow these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  allowCidr(cidr: string): this
  /**
   * Restriction placed on the origin of incoming connections to the edge to deny these CIDR ranges.
   * Call multiple times to add additional CIDR ranges.
   */
  denyCidr(cidr: string): this
  /** The version of PROXY protocol to use with this tunnel "1", "2", or "" if not using. */
  proxyProto(proxyProto: string): this
  /**
   * Tunnel backend metadata. Viewable via the dashboard and API, but has no
   * bearing on tunnel behavior.
   */
  forwardsTo(forwardsTo: string): this
}
/**r" A labeled ngrok tunnel. */
export class NgrokLabeledTunnelBuilder {
  /** Tunnel-specific opaque metadata. Viewable via the API. */
  metadata(metadata: string): this
  /** Begin listening for new connections on this tunnel. */
  listen(bind?: boolean | undefined | null): Promise<NgrokLabeledTunnel>
  /** Add a label, value pair for this tunnel. */
  label(label: string, value: string): this
}
/** Generate, or convert a given tunnel, into one that can be passed into net.Server.listen(). */
export function listenable(tunnel?: (NgrokHttpTunnel|NgrokTcpTunnel|NgrokTlsTunnel|NgrokLabeledTunnel)): (NgrokHttpTunnel|NgrokTcpTunnel|NgrokTlsTunnel|NgrokLabeledTunnel)
/** Start the given net.Server listening to a generated, or passed in, tunnel. */
export function listen(server: import("net").Server, tunnel?: (NgrokHttpTunnel|NgrokTcpTunnel|NgrokTlsTunnel|NgrokLabeledTunnel)): (NgrokHttpTunnel|NgrokTcpTunnel|NgrokTlsTunnel|NgrokLabeledTunnel)
/** 
 * Register a console.log callback for ngrok INFO logging.
 * Optionally set the logging level to one of ERROR, WARN, INFO, DEBUG, or TRACE.
 */
export function consoleLog(level?: String)
